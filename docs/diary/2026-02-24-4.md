# 日報 2026-02-24-4

## 今日やったこと

仕様書（国標準仕様書 第3.3版）を全ファイル精読し、実装との差異を洗い出して修正した。

### 仕様書確認

5ファイル（docx・xlsx×3・pptx）を全解析。主要な仕様差異を特定：

| 仕様 | 旧実装 | 修正後 |
|------|--------|--------|
| 照会中は登録番号・登録年月日が空欄（1.1.3） | id=登録番号（常に付番） | 内部IDと登録番号を分離、照会中は null |
| 印影の氏名区分（1.1.4）12区分 | sealName文字列のみ | SealNameCategory型追加、選択UIあり |
| 登録年月日は和暦表示 | ISO date文字列そのまま | Intl.DateTimeFormat で和暦変換 |
| 証明書に性別欄 | 性別なし | 証明書モーダルに性別欄追加 |
| 登録フロー: 即時/照会の2種類 | 常に即時登録 | 登録方法選択UI追加、照会は照会中状態で作成 |

### 実装内容

**データモデル（フロント/バックエンド共通）**

- `id`: 内部ID（URL用、変更不可）に役割を変更
- `registrationNumber: string | null`: 登録番号を新フィールドとして分離
- `registrationDate: string | null`: 照会中はnull
- `SealNameCategory`: 12区分の印影氏名区分型を追加
- `sealNameCategory`: SealRegistrationに追加
- `RegistrationMethod`: "即時" | "照会" 型を追加

**バックエンド（`src/api/`）**

- `types.ts`: 新型定義を反映
- `schemas.ts`: `SealNameCategorySchema`, `RegistrationMethodSchema` を追加
- `mock-db.ts`: モックデータを内部ID/登録番号分離形式に移行。照会中データは `registrationNumber: null, registrationDate: null`

**フロントエンド（`src/user-front/`）**

- `lib/date.ts` 新規作成: `formatToWareki(isoDate)` — ISO date → 和暦文字列変換
- `lib/types.ts`: 新型定義・定数 `SEAL_NAME_CATEGORIES` を追加
- `lib/api.ts`: create メソッドの型に `sealNameCategory`, `registrationMethod` を追加
- `lib/mock.ts`: モックデータを新型に合わせて更新
- `routes/home.tsx`: 登録番号を `registrationNumber ?? "—"` で表示、登録年月日を和暦表示
- `routes/registrations/new.tsx`: 印影氏名区分セレクト・登録方法ラジオボタンのUI追加
- `routes/registrations/$id.tsx`: 登録年月日和暦表示、証明書に性別欄追加、登録番号を `registrationNumber ?? "未付番"` で表示

## 今度やりたいこと

- テスト（Vitest）の追加
- a11yルール（`noLabelWithoutControl`等）の実際の修正（htmlFor追加）
- 異動履歴の記録・表示（仕様書 1.2）
- 照会フロー（照会取消・回答登録）の完全実装
- 実際のDB対応（Drizzle ORM + SQLite）
- 外国人住民対応（西暦生年月日、ローマ字氏名）

## 所感

仕様書を読んで一番驚いたのは異動事由の種類の多さ。登録・抹消・修正・照会、それぞれに細かい事由が定義されていてかなり複雑な業務フローになっている。今回はデータモデルの修正と主要な差異の修正に留めたが、本格的に準拠させるには異動履歴管理が最大の課題。

Gemini に設計の壁打ちをしたら「内部IDと登録番号を分離するアプローチA推奨」という明確な回答が得られた。和暦変換は `Intl.DateTimeFormat('ja-JP-u-ca-japanese')` で標準APIだけで完結するのもきれい。

## 学び

- 仕様書の「空欄を許容する項目」という概念は型システムで `string | null` として直接表現できる
- `Intl.DateTimeFormat('ja-JP-u-ca-japanese', { era: 'long', year: 'numeric', month: 'long', day: 'numeric' })` で和暦変換が外部ライブラリなしで実現できる
- 「登録番号」と「DBの主キー」を分離することで仕様変更に強い設計になる
